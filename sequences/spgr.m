function spgr(kspace,varargin)
% spgr sequence with arbitrary readout trajectory
% written in toppe v6 by David Frey
% kspace = kspace trajectory ([N x Nshots x 3] cm^-1)

%% Set defaults
if nargin < 1 || isempty(kspace)
    kspace = zeros(500,1,3); % zeros - FID
end

arg.fov = 20; % XY FOV (cm)
arg.N = 128; % image matrix size

arg.slthick = 2; % slice thickness (cm)
arg.slspace = 0; % slice spacing (cm)
arg.nslices = 1; % number of slices to acquire

arg.rffa = 10; % tipdown flip angle (deg)
arg.rftbw = 8; % tipdown time-bandwidth product
arg.rfdur = 3.2; % tipdown pulse duration (ms)
arg.rfspoil = 1; % option to do rf spoiling
arg.spoilcyc = 4; % number of phase cycles per voxel for gradient spoiling

arg.dofatsat = 1; % option to dplay fat sat pulse before readout
arg.fsfa = 90; % fatsat flip angle (deg)
arg.fstbw = 2; % fatsat time-bandwidth product
arg.fsdur = 3.2; % fatsat pulse duration (ms)
arg.fsdf = -440; % fatsat frequency offset (Hz)

arg.padtime = 500; % extra deadtime in each core (us)
arg.deadtime = 0; % extra deadtime at the end of each shot (ms)
arg.ndisdaqs = 0; % number of disdaq shots at beginning of sequence

% Parse variable inputs
arg = toppe.utils.vararg_pair(arg, varargin);

%% Generate pulse sequence modules
sys = toppe.systemspecs;

% Create tipdown SLR pulse
[~,~,rffreq] = toppe.utils.rf.makeslr( ...
    arg.rffa, ...
    arg.slthick, ...
    arg.rftbw, ...
    arg.rfdur, ...
    eps(), ...
    sys, ...
    'sliceOffset', arg.nslices*(arg.slthick + arg.slspace), ...
    'ofname', 'tipdown.mod' ...
    );

% Create the fatsat SLR pulse
toppe.utils.rf.makeslr( ...
    arg.fsfa, ...
    5, ... % dummy variable - we won't use the slicesel gradient
    arg.fstbw, ...
    arg.fsdur, ...
    0, ...
    sys, ...
    'ofname', 'fatsat.mod' ...
    );

% Generate the readout gradients
nshots = size(kspace,2);
[g,nramp] = gengrads(sys,kspace);
gx = g(:,:,1);
gy = g(:,:,2);
gz = g(:,:,3);
toppe.writemod(sys, ...
    'gx', gx, ...
    'gy', gy, ...
    'gz', gz, ...
    'nChop', nramp, ...
    'ofname', 'readout.mod');

% Create a crusher gradient
gspoil = toppe.utils.makecrusher(arg.spoilcyc, ...
    arg.slthick, ...
    sys, ...
    0, ...
    sys.maxSlew, ...
    sys.maxGrad);
toppe.writemod(sys, ...
    'gz', gspoil, ...
    'ofname', 'crusher.mod');

% Calculate all module durations
dur_tipdown = length(toppe.readmod('tipdown.mod'))*sys.raster + arg.padtime; % us
dur_fatsat = length(toppe.readmod('fatsat.mod'))*sys.raster + arg.padtime; % us
dur_readout = length(toppe.readmod('readout.mod'))*sys.raster + arg.padtime; % us
dur_crusher = length(toppe.readmod('crusher.mod'))*sys.raster + arg.padtime; % us

% Write entry file
toppe.writeentryfile('toppeN.entry');

% Set cores file text
coresfiletext = [ ...
    "2 4 1" % tipdown
    "2 2 4" % fatsat
    "1 3" % readout
    ];

% Set modules file text
modulesfiletext = [ ...
    sprintf("tipdown.mod %d 1 0 -1", dur_tipdown)
    sprintf("fatsat.mod %d 1 0 -1", dur_fatsat)
    sprintf("readout.mod %d 0 1 -1", dur_readout)
    sprintf("crusher.mod %d 0 0 -1", dur_crusher)
    ];

% Write out cores and modules files
writemodulesfile(modulesfiletext);
writecoresfile(coresfiletext);

%% Write the scan loop
toppe.write2loop('setup',sys,'version',6);
sloffset = round(linspace(-rffreq,rffreq,arg.nslices));
for shotn = 1-arg.ndisdaqs:nshots % loop through shots
    for slicen = 1:arg.nslices % loop through slices

        % Write fatsat to loop
        if arg.dofatsat
            toppe.write2loop('fatsat.mod', sys, ...
                'RFoffset', arg.fsdf, ...
                'RFphase', 0, ...
                'Gamplitude', [0;0;0], ...
                'version', 6, ...
                'trigout', 0, ...
                'core', 2);

            toppe.write2loop('crusher.mod', sys, ...
                'version', 6, ...
                'trigout', 0, ...
                'core', 2);
        end

        % Write tipdown to loop
        toppe.write2loop('crusher.mod', sys, ...
            'version', 6, ...
            'trigout', 0, ...
            'core', 1);
        toppe.write2loop('tipdown.mod', sys, ...
            'RFspoil', arg.rfspoil, ...
            'RFoffset', sloffset(slicen), ...
            'RFphase', 0, ...
            'version', 6, ...
            'trigout', 0, ...
            'core', 1);

        % Write readout to loop
        if shotn > 0
            toppe.write2loop('readout.mod', sys, ...
                'RFspoil', arg.rfspoil, ...
                'echo', 1, ...
                'slice', slicen, ...
                'view', shotn, ...
                'waveform', shotn, ...
                'RFphase', 0, ...
                'version', 6, ...
                'trigout', 0, ...
                'dabmode', 'on', ...
                'textra', arg.deadtime, ...
                'core', 3);
        else
            toppe.write2loop('readout.mod', sys, ...
                'RFspoil', arg.rfspoil, ...
                'version', 6, ...
                'RFphase', 0, ...
                'trigout', 0, ...
                'dabmode', 'off', ...
                'textra', arg.deadtime, ...
                'core', 3);
        end

    end
end

% Finish loop
toppe.write2loop('finish',sys);
toppe.preflightcheck('toppeN.entry','seqstamp.txt',sys);

end